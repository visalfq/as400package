
"use strict";

if (global.PROFOUNDJS_STRANDS) {
  module.exports = global.PROFOUNDJS_STRANDS;
  return;
}

const { AsyncLocalStorage } = require("async_hooks");
const callsite = require("callsite");
const debug = require("debug")("profoundjs-strands");

const asyncLocalStorage = new AsyncLocalStorage();

class Strand {
  constructor(fn) {
    this._fn = fn;
    this._started = this._yielding = false;
  }
  async run(param) {
    if (!this._started) {
      const error = new Error(
        "Program ended while yielding. A call to a Profound.js API or Fiber-wrapped function is missing \"await\".\n" +
        "See: https://docs.profoundlogic.com/x/Oh2dBQ"
      );
      try {
        this._started = true;
        return await asyncLocalStorage.run(this, async () => {
          return await this._fn(param);
        });
      }
      finally {
        this._started = false;
        if (this._yielding) {
          error.yieldStack = formatStack(this._yieldStack);
          this._yielding = false;
          delete this._resolve;
          delete this._reject;
          delete this._yieldStack;
          throw error;
        }
      }
    }
    else if (!this._yielding) {
      throw new Error("This Fiber is already running");
    }
    else {
      this._resolve(param);
      return param;
    }
  }
  async yield() {
    if (!this._started) {
      throw new Error("This Fiber is not running");
    }
    else if (this._yielding) {
      const formatted = formatStack(this._yieldStack);
      debug("call stack for prior yield:\n%O", formatted);
      const error = new Error(
        "Profound.js API or Fiber-wrapped function called with previous call yielding. This means that a prior call to a Profound.js API or Fiber-wrapped function is missing \"await\".\n" +
        "See: https://docs.profoundlogic.com/x/nQ_dBQ"
      );
      error.yieldStack = formatted;
      throw error;
    }
    else {
      return new Promise((resolve, reject) => {
        this._yielding = true;
        this._yieldStack = callsite();
        this._resolve = (...args) => {
          this._yielding = false;
          delete this._resolve;
          delete this._reject;
          delete this._yieldStack;
          resolve(...args);
        }
        this._reject = (error) => {
          this._yielding = false;
          delete this._resolve;
          delete this._reject;
          delete this._yieldStack;
          reject(error);
        }
      });
    }
  }
  throwInto(error) {
    if (!this._started)
      throw new Error("This Fiber is not running");
    else if (!this._yielding)
      throw new Error("This Fiber is not yielding");
    else
      this._reject(error);
  }
}

const Strands = function(fn) {
  const strand = new Strand(fn);
  return strand;
}

Strands.yield = async () => {
  const strand = Strands.current;
  if (!strand)
    throw new Error("yield() called with no fiber running");
  return strand.yield();
}

Object.defineProperty(
  Strands,
  "current",
  {
    enumerable: true,
    get: () => {
      return asyncLocalStorage.getStore();
    }
  }
);

global.PROFOUNDJS_STRANDS = module.exports = Strands;

function formatStack(stack) {

  return stack.map(entry => {
    const fn = entry.getFunctionName() || "(Anonymous)";
    const file = entry.getFileName() || "";
    const line = entry.getLineNumber();
    const col = entry.getColumnNumber();
    entry = fn + " " + file;
    if (line !== null && col !== null) {
      entry += ":" + line + "," + col;
    }
    return entry;
  });

}
